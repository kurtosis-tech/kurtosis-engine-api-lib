syntax = "proto3";
package engine_api;
// NOTE: It sucks that we have this Go-specific logic inside this file (which should be language-agnostic). However, the Protobuf team have
// taken a hard stance on this being the way it should be done, so we have to do it this way.
option go_package = "github.com/kurtosis-tech/kurtosis-engine-api-lib/golang/kurtosis_engine_rpc_api_bindings";

import "google/protobuf/empty.proto";

service EngineService {
  // Creates a new Kurtosis Enclave
  rpc CreateEnclave(CreateEnclaveArgs) returns (CreateEnclaveResponse) {};
  // Get a running Kurtosis Enclave
  rpc GetEnclave(GetEnclaveArgs) returns (GetEnclaveResponse) {};
  // Stops all containers in an enclave
  rpc StopEnclave(StopEnclaveArgs) returns (google.protobuf.Empty) {};
  // Destroys an enclave, removing all artifacts associated with it
  rpc DestroyEnclave(DestroyEnclaveArgs) returns (google.protobuf.Empty) {};
}

// ==============================================================================================
//                                        Create Enclave
// ==============================================================================================
message CreateEnclaveArgs {
  //The ID of the new Kurtosis Enclave
  string enclave_id = 1;
  //The API container Docker image name which will be used to start the API container inside the Kurtosis Enclave
  string api_container_image = 2;
  //The API container log level
  string api_container_log_level = 3;
  //Whether network partitioning will be enabled or not on the new Kurtosis Enclave
  bool is_partitioning_enabled = 4;
  //If true, when a container is started in the enclave then all its used ports will also be made available on the host machine
  bool should_publish_all_ports = 5;
}

message CreateEnclaveResponse {
  //The Docker network id that is part of the Kurtosis Enclave
  string network_id = 1;
  //The Docker network CIDR
  string network_cidr = 2;
  //The API container ID that is currently running in the Kurtosis Enclave
  string api_container_id = 3;
  //The IP of the interface on the host machine where the API container's port can be accessed
  string api_container_ip_inside_network = 4;
  //The API container Host IP address
  string api_container_host_ip = 5;
  //The port number on the host machine where the API container can be reached
  string api_container_host_port = 6;
}

// ==============================================================================================
//                                          Get Enclave
// ==============================================================================================
message GetEnclaveArgs {
  //The ID of the enclave to retrieve
  string enclave_id = 1;
}

message GetEnclaveResponse {
  //The Docker network id that is part of the Kurtosis Enclave
  string network_id = 1;
  //The Docker network CIDR
  string network_cidr = 2;
  //The API container ID that is currently running in the Kurtosis Enclave
  string api_container_id = 3;
  //The IP of the interface on the host machine where the API container's port can be accessed
  string api_container_ip_inside_network = 4;
  //The API container Host IP address
  string api_container_host_ip = 5;
  //The port number on the host machine where the API container can be reached
  string api_container_host_port = 6;
}


// ==============================================================================================
//                                       Destroy Enclave
// ==============================================================================================
message StopEnclaveArgs {
  //The ID of the Kurtosis enclave to stop
  string enclave_id = 1;
}



// ==============================================================================================
//                                       Destroy Enclave
// ==============================================================================================
message DestroyEnclaveArgs {
  //The ID of the Kurtosis enclave to destroy
  string enclave_id = 1;
}
