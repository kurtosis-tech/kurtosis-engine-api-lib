syntax = "proto3";
package engine_api;
// NOTE: It sucks that we have this Go-specific logic inside this file (which should be language-agnostic). However, the Protobuf team have
// taken a hard stance on this being the way it should be done, so we have to do it this way.
option go_package = "github.com/kurtosis-tech/kurtosis-engine-api-lib/golang/kurtosis_engine_rpc_api_bindings";

import "google/protobuf/empty.proto";

service EngineService {
  // Endpoint for getting information about the engine, which is also what we use to verify that the engine has become available
  rpc GetEngineInfo(google.protobuf.Empty) returns (GetEngineInfoResponse) {};

  // ==============================================================================================
  //                                   Enclave Management
  // ==============================================================================================
  // Creates a new Kurtosis Enclave
  rpc CreateEnclave(CreateEnclaveArgs) returns (CreateEnclaveResponse) {};
  // Returns information about the existing enclaves
  rpc GetEnclaves(google.protobuf.Empty) returns (GetEnclavesResponse) {};
  // Stops all containers in an enclave
  rpc StopEnclave(StopEnclaveArgs) returns (google.protobuf.Empty) {};
  // Destroys an enclave, removing all artifacts associated with it
  rpc DestroyEnclave(DestroyEnclaveArgs) returns (google.protobuf.Empty) {};

  // ==============================================================================================
  //                                    Enclave-Internal
  // ==============================================================================================
  // Starts the registration of an external container (started by a third-party source, not the API container)
  rpc StartExternalContainerRegistration(google.protobuf.Empty) returns (StartExternalContainerRegistrationResponse) {};

  // Finishes the registration of an container (started by a third-party source, not the API contianer) that was started previously
  // NOTE: It's important not to forget to finish this registration, else the external container won't be recognized by the API container!
  rpc FinishExternalContainerRegistration(FinishExternalContainerRegistrationArgs) returns (google.protobuf.Empty) {};

  // Starts a module container in the enclave
  rpc LoadModule(LoadModuleArgs) returns (google.protobuf.Empty) {};

  // Stop and remove a module from the enclave
  rpc UnloadModule(UnloadModuleArgs) returns (google.protobuf.Empty) {};

  // Executes an executable module on the user's behalf
  rpc ExecuteModule(ExecuteModuleArgs) returns (ExecuteModuleResponse) {};

  // Gets information about a loaded module
  rpc GetModuleInfo(GetModuleInfoArgs) returns (GetModuleInfoResponse) {};

  // Tells the API container that the client has files artifacts from the web that it would like the API container to know about
  // The API container will download these artifacts locally, so they're available when launching services
  rpc RegisterFilesArtifacts(RegisterFilesArtifactsArgs) returns (google.protobuf.Empty) {};

  // Registers a service with the API container but doesn't start the container for it
  rpc RegisterService(RegisterServiceArgs) returns (RegisterServiceResponse) {};

  // Starts a previously-registered service by creating a Docker container for it
  rpc StartService(StartServiceArgs) returns (StartServiceResponse) {};

  // Returns relevant information about the service
  rpc GetServiceInfo(GetServiceInfoArgs) returns (GetServiceInfoResponse) {};

  // Instructs the API container to remove the given service
  rpc RemoveService(RemoveServiceArgs) returns (google.protobuf.Empty) {};

  // Instructs the API container to repartition the test network
  rpc Repartition(RepartitionArgs) returns (google.protobuf.Empty) {};

  // Executes the given command inside a running container
  rpc ExecCommand(ExecCommandArgs) returns (ExecCommandResponse) {};

  // Block until the given HTTP endpoint returns available, calling it through a HTTP Get request
  rpc WaitForHttpGetEndpointAvailability(WaitForHttpGetEndpointAvailabilityArgs) returns (google.protobuf.Empty) {};

  // Block until the given HTTP endpoint returns available, calling it through a HTTP Post request
  rpc WaitForHttpPostEndpointAvailability(WaitForHttpPostEndpointAvailabilityArgs) returns (google.protobuf.Empty) {};

  // Executes multiple commands at once
  rpc ExecuteBulkCommands(ExecuteBulkCommandsArgs) returns (google.protobuf.Empty) {};

  // Returns the IDs of the current services in the test network
  rpc GetServices(GetServicesArgs) returns (GetServicesResponse) {};

  // Returns the IDs of the Kurtosis modules that have been loaded into the enclave
  rpc GetModules(GetModulesArgs) returns (GetModulesResponse) {};
}

// ==============================================================================================
//                                        Get Engine Info
// ==============================================================================================
message GetEngineInfoResponse {
  // Version of the engine API that this server implements
  string engine_api_version = 1;
}

// ==============================================================================================
//                                        Create Enclave
// ==============================================================================================
message CreateEnclaveArgs {
  //The ID of the new Kurtosis Enclave
  string enclave_id = 1;
  //The API container Docker image name which will be used to start the API container inside the Kurtosis Enclave
  string api_container_image = 2;
  //The API container log level
  string api_container_log_level = 3;
  //Whether network partitioning will be enabled or not on the new Kurtosis Enclave
  bool is_partitioning_enabled = 4;
  //If true, when a container is started in the enclave then all its used ports will also be made available on the host machine
  bool should_publish_all_ports = 5;
}

message CreateEnclaveResponse {
  //All the enclave information inside this object
  EnclaveInfo enclave_info = 1;
}

// ==============================================================================================
//                                            Get Enclaves
// ==============================================================================================
// Status of the containers in the enclave
// NOTE: We have to prefix the enum values with the enum name due to the way Protobuf enum valuee uniqueness works
enum EnclaveContainersStatus {
  // The enclave has been created, but there are no containers inside it
  EnclaveContainersStatus_EMPTY = 0;

  // One or more containers are running in the enclave (which may or may not include the API container, depending on if the user was manually stopping/removing containers)
  EnclaveContainersStatus_RUNNING = 1;

  // There are >= 1 container in the enclave, but they're all stopped
  EnclaveContainersStatus_STOPPED = 2;
}

// NOTE: We have to prefix the enum values with the enum name due to the way Protobuf enum value uniqueness works
enum EnclaveAPIContainerStatus {
  // No API container exists in the enclave
  // This is the only valid value when the enclave containers status is "EMPTY"
  EnclaveAPIContainerStatus_NONEXISTENT = 0;

  // An API container exists and is running
  // NOTE: this does NOT say that the server inside the API container is available, because checking if it's available requires making a call to the API container
  //  If we have a lot of API containers, we'd be making tons of calls
  EnclaveAPIContainerStatus_RUNNING = 1;

  // An API container exists, but isn't running
  EnclaveAPIContainerStatus_STOPPED = 2;
}

message EnclaveAPIContainerInfo {
  //The container engine ID of the API container
  string container_id = 1;
  // The IP inside the enclave network of the API container (i.e. how services inside the network can reach the API container)
  string ip_inside_enclave = 2;
  // The port inside the enclave network that the API container is listening on
  uint32 port_inside_enclave = 3;
}

// Will only be present if the API container is running
message EnclaveAPIContainerHostMachineInfo {
  // The interface IP on the container engine host machine where the API container can be reached
  string ip_on_host_machine = 4;
  // The port on the container engine host machine where the API container can be reached
  uint32 port_on_host_machine = 5;
}

// Enclaves are defined by a network in the container system, which is why there's a bunch of network information here
message EnclaveInfo {
  // ID of the enclave
  string enclave_id = 1;

  // The ID of the enclave's network in the container engine
  string network_id = 2;

  //The CIDR of the enclave's network in the container engine
  string network_cidr = 3;

  // State of all containers in the enclave
  EnclaveContainersStatus containers_status = 4;

  // State specifically of the API container
  EnclaveAPIContainerStatus api_container_status = 5;

  // NOTE: Will not be present if the API container status is "NONEXISTENT"!!
  EnclaveAPIContainerInfo api_container_info = 6;

  // NOTE: Will not be present if the API container status is not "RUNNING"!!
  EnclaveAPIContainerHostMachineInfo api_container_host_machine_info = 7;
}

message GetEnclavesResponse {
  // Mapping of enclave_id -> info_about_enclave
  map<string, EnclaveInfo> enclave_info = 1;
}

// ==============================================================================================
//                                       Stop Enclave
// ==============================================================================================
message StopEnclaveArgs {
  //The ID of the Kurtosis enclave to stop
  string enclave_id = 1;
}



// ==============================================================================================
//                                       Destroy Enclave
// ==============================================================================================
message DestroyEnclaveArgs {
  //The ID of the Kurtosis enclave to destroy
  string enclave_id = 1;
}

// ==============================================================================================
//                           Start External Container Registration 
// ==============================================================================================
message StartExternalContainerRegistrationResponse {
  string enclave_id = 1;

  // A key that should be passed to the call to finish external container registration
  string registration_key = 2;

  // The IP address that the API container has set aside for the container-to-be-registered
  string ip_addr = 3;
}


// ==============================================================================================
//                           Finish External Container Registration 
// ==============================================================================================
message FinishExternalContainerRegistrationArgs {
  string enclave_id = 1;

  // The key that was returned from the call to start external container registration
  string registration_key = 2;

  // The container ID of the container that is now inside the network
  string container_id = 3;
}

// ==============================================================================================
//                                     Load Module
// ==============================================================================================
message LoadModuleArgs {
  string enclave_id = 1;

  string module_id = 2;

  string container_imwge = 3;

  // The serialized params object that will be passed, as-is, to the module for starting
  // The serialization format is dependent on the module
  string serialized_params = 4;
}

// ==============================================================================================
//                                     Unload Module
// ==============================================================================================
message UnloadModuleArgs {
  string enclave_id = 1;

  string module_id = 2;
}

// ==============================================================================================
//                                     Execute Module
// ==============================================================================================
message ExecuteModuleArgs {
  string enclave_id = 1;

  string module_id = 2;

  // Serialized parameters data for the module's execute function
  // The serialization format is dependent on the Module
  string serialized_params = 3;
}

message ExecuteModuleResponse {
  // Serialized result data from the module's execute function
  // The serialization format is dependent on the Module
  string serialized_result = 1;
}

// ==============================================================================================
//                                     Get Module Info
// ==============================================================================================
message GetModuleInfoArgs {
  string enclave_id = 1;

  string module_id = 2;
}

message GetModuleInfoResponse {
  string ip_addr = 1;
}

// ==============================================================================================
//                                       Register Files Artifacts
// ==============================================================================================
message RegisterFilesArtifactsArgs {
  string enclave_id = 1;

  // A mapping of user_defined_id -> url_of_file_artifact
  map<string, string> files_artifact_urls = 2;
}

// ==============================================================================================
//                                     Register Service
// ==============================================================================================
message RegisterServiceArgs {
  string enclave_id = 1;

  // ID that will be used to identify the service going forward
  string service_id = 2;

  // If emptystring, the default partition ID will be used
  string partition_id = 3;
}

message RegisterServiceResponse {
  // The IP address that the service will receive when it starts
  string ip_addr = 1;

  // The dirpath where the service's directory exists inside the enclave data directory, relative to the enclave data dir root
  string relative_service_dirpath =2;
}

// ==============================================================================================
//                                        Start Service
// ==============================================================================================
message StartServiceArgs {
  string enclave_id = 1;

  // ID of the previously-registered service that should be started
  string service_id = 2;

  string docker_image = 3;

  // "Set" of ports that the running service will listen on
  // This is a string because it's Docker port specification syntax, e.g. "80" (default TCP) or "80/udp"
  map<string, bool> used_ports = 4;

  // Corresponds to a Dockerfile's ENTRYPOINT directive; leave blank to do no overriding
  repeated string entrypoint_args = 5;

  // Corresponds to a Dockerfile's CMD directive; leave blank to do no overriding
  repeated string cmd_args = 6;

  // Docker environment variables that should be set in the service's container
  map<string, string> docker_env_vars = 7;

  // The full path where the API container should mount the enclave data directory on the service container
  string enclave_data_dir_mnt_dirpath = 8;

  // Mapping of files_artifact_id -> filepath_on_container_to_mount_artifact_contents
  map<string, string> files_artifact_mount_dirpaths = 9;
}

message StartServiceResponse {
  // Mapping of used_ports_provided_in_input_args -> ip_and_port_on_host_where_port_is_bound (in ip:port form)
  // Ports will only be in this map if they were successfully bound to a host port; if no ports were bound, then
  // this map will be empty
  map<string, PortBinding> used_ports_host_port_bindings = 1;
}

message PortBinding {
  string interface_ip = 1;

  string interface_port = 2;
}

// ==============================================================================================
//                                       Get Service Info
// ==============================================================================================
message GetServiceInfoArgs {
  string enclave_id = 1;

  //The service ID to get the info from
  string service_id = 2;
}

message GetServiceInfoResponse {
  // The IP address of the service
  string ip_addr = 1;

  // The full path where the enclave data dir is mounted on the service
  string enclave_data_dir_mount_dirpath = 2;

  // The dirpath where the service's directory exists inside the enclave data directory, relative to the enclave data directory root
  string relative_service_dirpath = 3;
}

// ==============================================================================================
//                                        Remove Service
// ==============================================================================================
message RemoveServiceArgs {
  string enclave_id = 1;

  string service_id = 2;

  // How long to wait for the service to gracefully stop before hard killing it
  uint64 container_stop_timeout_seconds = 3;
}

// ==============================================================================================
//                                          Repartition
// ==============================================================================================
message RepartitionArgs {
  string enclave_id = 1;

  // Definition of partitionId -> services that should be inside the partition after repartitioning
  map<string, PartitionServices> partition_services = 2;

  // Definition of partitionIdA -> partitionIdB -> information defining the connection between A <-> B
  map<string, PartitionConnections> partition_connections = 3;

  // Information about the default inter-partition connection to set up if one is not defined in the
  //  partition connections map
  PartitionConnectionInfo default_connection = 4;
}

message PartitionServices {
  // "Set" of service IDs in partition
  map<string, bool> service_id_set = 1;
}

message PartitionConnections {
  map<string, PartitionConnectionInfo> connection_info = 1;
}

message PartitionConnectionInfo {
  // Whether network traffic is allowed between the two partitions
  bool is_blocked = 1;
}

// ==============================================================================================
//                                          Exec Command
// ==============================================================================================
message ExecCommandArgs {
  string enclave_id = 1;

  // The service ID of the container that the command should be executed in
  string service_id = 2;

  repeated string command_args = 3;
}

message ExecCommandResponse {
  int32 exit_code = 1;

  // Assumes UTF-8 encoding
  string log_output = 2;
}

// ==============================================================================================
//                             Wait For HTTP Get Endpoint Availability
// ==============================================================================================
message WaitForHttpGetEndpointAvailabilityArgs {
  string enclave_id = 1;

  //The ID of the service to check.
  string service_id = 2;

  //The port of the service to check. For instance 8080
  uint32 port = 3;

  //The path of the service to check. It mustn't start with the first slash. For instance `service/health`
  string path = 4;

  //The number of milliseconds to wait until executing the first HTTP call
  uint32 initial_delay_milliseconds = 5;

  //Max number of HTTP call attempts that this will execute until giving up and returning an error
  uint32 retries = 6;

  //Number of milliseconds to wait between retries
  uint32 retries_delay_milliseconds = 7;

  //If the endpoint returns this value, the service will be marked as available (e.g. Hello World).
  string body_text = 8;
}

// ==============================================================================================
//                           Wait For HTTP Post Endpoint Availability
// ==============================================================================================
message WaitForHttpPostEndpointAvailabilityArgs {
  string enclave_id = 1;

  //The ID of the service to check.
  string service_id = 2;

  //The port of the service to check. For instance 8080
  uint32 port = 3;

  //The path of the service to check. It mustn't start with the first slash. For instance `service/health`
  string path = 4;

  //The content of the request body.
  string request_body = 5;

  //The number of milliseconds to wait until executing the first HTTP call
  uint32 initial_delay_milliseconds = 6;

  //Max number of HTTP call attempts that this will execute until giving up and returning an error
  uint32 retries = 7;

  //Number of milliseconds to wait between retries
  uint32 retries_delay_milliseconds = 8;

  //If the endpoint returns this value, the service will be marked as available (e.g. Hello World).
  string body_text = 9;
}

// ==============================================================================================
//                                      Execute Bulk Commands
// ==============================================================================================
message ExecuteBulkCommandsArgs {
  string enclave_id = 1;

  // Commands, serialized as JSON
  string serialized_commands = 2;
}

// ==============================================================================================
//                                          Get Services
// ==============================================================================================
message GetServicesArgs {
  string enclave_id = 1;
}

message GetServicesResponse {
  // "Set" of current service IDs in the test network
  map<string, bool> service_ids = 1;
}

// ==============================================================================================
//                                          Get Modules
// ==============================================================================================
message GetModulesArgs {
  string enclave_id = 1;
}

message GetModulesResponse {
  // "Set" of current Kurtosis module IDs loaded in the test network
  map<string, bool> module_ids = 1;
}
